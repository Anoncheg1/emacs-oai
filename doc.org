;-*- mode: Org; fill-column: 110;-*-
* preparation steps of block content for LLM
*oai-restapi-request-prepare chain* that call `oai-restapi-prepare-content'
1) oai-restapi--collect-chat-messages-at-point
  + oai-block-get-content - string
  + oai-block-tags-replace - string
  + oai-restapi--collect-chat-messages - vector
  + oai-block--collect-chat-messages-from-string
    - oai-block--collect-chat-messages
2) (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags-replace))
3) (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags--clear-properties))


*oai-prompt.el chain* for `oai-prompt-request-chain' function
1) oai-restapi--collect-chat-messages-at-point - vector
3) oai-restapi-request-llm-retries ->
  - (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags-replace))
  - (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags--clear-properties))

* Hooks - messages preparation for sending or content reading
cases:
- blend all messages to a one text at `oai-block-get-content' step
- blend messages at `oai-restapi-prepare-content' step
- change something in the “last-user-content”
- format text in all messages one by one

May be implemented at:
| operate at raw text level:        | oai-restapi--collect-chat-messages                              |

| operate at messages vector level: | oai-restapi-prepare-content and oai-restapi-request-llm-retries |

Solution:
- before any - raw text level: as `oai-block-parse-part-hook' in `oai-block--parse-part'
- after all - vector level: as `oai-restapi-after-prepare-messages-hook' in `oai-restapi-request-llm-retries' and in `oai-restapi-prepare-content'
* Hook - HTTP headers before sending
[[file:~/sources/emacs-oai/oai-restapi.el::680::(defun oai-restapi--get-headers (service)]]
* Main path of JSON decoding
For not stream
- `oai-restapi--url-request-on-change-function' ->
- `oai-restapi--get-single-response-text' ->
- `oai-block--insert-single-response' ->
- `insert'

for stream:
- `oai-restapi--url-request-on-change-function' ->
- `oai-block--insert-stream-response' -> may be used for single response.
- `oai-restapi--normalize-response' ->
- `insert'

To read data from JSON there is two ways (json-read) and (json-read-from-string), we specify plist as target,
 so we use (plist-get data 'choices) instead of (alist-get 'choices data).
* Regex: file path
: "@\\(\\.\\.?\\|\\.\\.?/\\|\\.\\.?\\\\\\|/\\|\\\\\\|[A-Za-z]:\\\\\\|~[a-zA-Z0-9_.-]*/*\\)[a-zA-Z0-9_./\\\\-]*"

### 1. Prefix: `"@"`
- **Matches:** Literal character `@` at the start of the path string.
- **Purpose:** Likely used in a markup or custom syntax to indicate
 the start of a path.

---
### 2. Initial Path Segment:
`\\( ... \\)` is a group using alternation (`\\|`) to match different
 path prefixes:

#### `\\.\\.?`
- **Matches:** `.` or `..`
- **Purpose:** Bare dot or double dot for current/parent directory
 (less common alone).

####  `\\.\\.?/`
- **Matches:** `./` or `../`
- **Purpose:** Relative Unix paths (current and parent directory).

####  `\\.\\.?\\\\`
- **Matches:** `.\\` or `..\\`
- **Purpose:** Relative Windows paths.

####  `/`
- **Matches:** `/`
- **Purpose:** Unix-style absolute path.

####  `\\\\`
- **Matches:** `\`
- **Purpose:** Windows-style absolute path.

####  `[A-Za-z]:\\\\`
- **Matches:** For example, `C:\`
- **Purpose:** Windows drive letter root.

####  `~[a-zA-Z0-9_.-]*/*`
- **Matches:** `~`, `~/`, `~user/`, `~user`
- **Purpose:** Linux/Unix home or other user's home directory, with
 optional trailing slash.

---
### 3. Path Body: `[a-zA-Z0-9_./\\\\-]*`
- **Matches:** Zero or more valid path characters:
    - Letters (`a-zA-Z`)
    - Digits (`0-9`)
    - Underscore (`_`)
    - Dot (`.`)
    - Slash (`/`)
    - Backslash (`\\`)
    - Dash (`-`)
- **Purpose:** Matches the remainder of the path, including
 directories and filenames composed of these characters.

---
## Summary Table
| Segment                   | Example Match      | Interpretation                |
|---------------------------|-------------------|-------------------------------|
| `@`                       | `@`               | Path marker                   |
| `./`, `../`               | `@./foo`          | Unix relative path            |
| `.\\`, `..\\`             | `@.\\foo`         | Windows relative path         |
| `/`                       | `@/etc/passwd`    | Unix absolute path            |
| `\`                       | `@\\windows`      | Windows absolute path         |
| `[A-Za-z]:\`              | `@C:\Users`       | Windows drive letter root     |
| `~`, `~/foo`, `~user/doc` | `@~/.bashrc`      | Unix home directories         |
| Path body                 | `/foo/bar-1`      | Subdirectories/files          |

* Regex: markdown ** asterisk
: "\\(^\\|[^*]\\)\\(\\*\\*\\*\\|\\*\\*\\)"
used in the markdown fontifier.

---
# Explanation by Parts
## 1. Regex Structure
- `\\(^\\|[^*]\\)` — **Group 1**:
  Matches either the beginning of a line (`^`),
  **OR** any character that is NOT an asterisk (`[^*]`).

- `\\(\\*\\*\\*\\|\\*\\*\\)` — **Group 2**:
  Matches either three asterisks (`***`)
  **OR** two asterisks (`**`).
  (The backslashes `\\` are needed for escaping in Elisp strings.)

## 2. Why This Structure?
- **Objective:**
  Find "**" or "***" markers in the text,
  but avoid matching sequences where asterisks are part of a longer
 run (like "****")
  and avoid overlapping matches.

- By requiring either line start or a non-asterisk before the marker,
  you reduce false positives and overlapping matches.

## 3. Match Groups
- **Group 1**: Context before the marker (not fontified).
- **Group 2**: The bold marker itself (to be fontified).

## 4. How It Works in Practice
### Example 1: Simple start-of-line
```
**bold**
```
- At position 0: Line start, matches `^`
- Next: "**" matches Group 2.

### Example 2: After space
```
some **bold**
```
- The space is not an asterisk, so `[^*]` matches.
- "**" matches Group 2.

### Example 3: Avoid overlap
```
****bold****
```
- After the first "**", the next "*" is part of "****",
  so `[^*]` doesn't match.
- Only the initial "**" or "***" are targeted.

---
# Summary Table
| Part                | Meaning                               |
|---------------------|---------------------------------------|
| `\\(^\\|[^*]\\)`    | Start of line OR not an asterisk      |
| `\\*\\*\\*\\|\\*\\*`| "***" OR "**" (the marker itself)     |

* Tests: Not covered staff
- font-locks
- fill paragraph
