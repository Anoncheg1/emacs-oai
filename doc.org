;-*- mode: Org; fill-column: 110;-*-
* Feature: tags, links, noweb, arguments
- tags, links
- noweb - expand references (If :noweb parameter or ~oai-noweb~ Org property is set.) but don't evaluated or referenced itself. see [[*Org noweb]]

Replacing links trigger noweb links in target blocks and replacing links in them also.

For sending request we replace links in all user messages, for expansion of links and tags we replace links in the last user message only. Also expand noweb in ~oai-block-get-content~ and in ~oai-block-tags-get-content~.

Arguments not implemented: https://orgmode.org/manual/Environment-of-a-Code-Block.html
* preparation steps of block content for LLM
*oai-restapi-request-prepare chain* that call `oai-restapi-prepare-content'
1) oai-restapi--collect-chat-messages-at-point
  + oai-block-get-content - string
  + oai-block-tags-replace - string
  + oai-restapi--collect-chat-messages - vector
  + oai-block--collect-chat-messages-from-string
    - oai-block--collect-chat-messages
2) (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags-replace))
3) (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags--clear-properties))


*oai-prompt.el chain* for `oai-prompt-request-chain' function
1) oai-restapi--collect-chat-messages-at-point - vector
3) oai-restapi-request-llm-retries ->
  - (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags-replace))
  - (messages (oai-restapi--modify-vector-content messages 'user #'oai-block-tags--clear-properties))

* Hooks - messages preparation for sending or content reading
cases:
- blend all messages to a one text at `oai-block-get-content' step
- blend messages at `oai-restapi-prepare-content' step
- change something in the “last-user-content”
- format text in all messages one by one

May be implemented at:
| operate at raw text level:        | oai-restapi--collect-chat-messages                              |

| operate at messages vector level: | oai-restapi-prepare-content and oai-restapi-request-llm-retries |

Solution:
- before any - raw text level: as `oai-block-parse-part-hook' in `oai-block--parse-part'
- after all - vector level: as `oai-restapi-after-prepare-messages-hook' in `oai-restapi-request-llm-retries' and in `oai-restapi-prepare-content'
* Hook - HTTP headers before sending
[[file:~/sources/emacs-oai/oai-restapi.el::680::(defun oai-restapi--get-headers (service)]]
* Main path of JSON decoding
For not stream
- `oai-restapi--url-request-on-change-function' ->
- `oai-restapi--get-single-response-text' ->
- `oai-block--insert-single-response' ->
- `insert'

for stream:
- `oai-restapi--url-request-on-change-function' ->
- `oai-block--insert-stream-response' -> may be used for single response.
- `oai-restapi--normalize-response' ->
- `insert'

To read data from JSON there is two ways (json-read) and (json-read-from-string), we specify plist as target,
 so we use (plist-get data 'choices) instead of (alist-get 'choices data).
* Regex: file path
: "@\\(\\.\\.?\\|\\.\\.?/\\|\\.\\.?\\\\\\|/\\|\\\\\\|[A-Za-z]:\\\\\\|~[a-zA-Z0-9_.-]*/*\\)[a-zA-Z0-9_./\\\\-]*"

### 1. Prefix: `"@"`
- **Matches:** Literal character `@` at the start of the path string.
- **Purpose:** Likely used in a markup or custom syntax to indicate
 the start of a path.

---
### 2. Initial Path Segment:
`\\( ... \\)` is a group using alternation (`\\|`) to match different
 path prefixes:

#### `\\.\\.?`
- **Matches:** `.` or `..`
- **Purpose:** Bare dot or double dot for current/parent directory
 (less common alone).

####  `\\.\\.?/`
- **Matches:** `./` or `../`
- **Purpose:** Relative Unix paths (current and parent directory).

####  `\\.\\.?\\\\`
- **Matches:** `.\\` or `..\\`
- **Purpose:** Relative Windows paths.

####  `/`
- **Matches:** `/`
- **Purpose:** Unix-style absolute path.

####  `\\\\`
- **Matches:** `\`
- **Purpose:** Windows-style absolute path.

####  `[A-Za-z]:\\\\`
- **Matches:** For example, `C:\`
- **Purpose:** Windows drive letter root.

####  `~[a-zA-Z0-9_.-]*/*`
- **Matches:** `~`, `~/`, `~user/`, `~user`
- **Purpose:** Linux/Unix home or other user's home directory, with
 optional trailing slash.

---
### 3. Path Body: `[a-zA-Z0-9_./\\\\-]*`
- **Matches:** Zero or more valid path characters:
    - Letters (`a-zA-Z`)
    - Digits (`0-9`)
    - Underscore (`_`)
    - Dot (`.`)
    - Slash (`/`)
    - Backslash (`\\`)
    - Dash (`-`)
- **Purpose:** Matches the remainder of the path, including
 directories and filenames composed of these characters.

---
## Summary Table
| Segment                   | Example Match      | Interpretation                |
|---------------------------|-------------------|-------------------------------|
| `@`                       | `@`               | Path marker                   |
| `./`, `../`               | `@./foo`          | Unix relative path            |
| `.\\`, `..\\`             | `@.\\foo`         | Windows relative path         |
| `/`                       | `@/etc/passwd`    | Unix absolute path            |
| `\`                       | `@\\windows`      | Windows absolute path         |
| `[A-Za-z]:\`              | `@C:\Users`       | Windows drive letter root     |
| `~`, `~/foo`, `~user/doc` | `@~/.bashrc`      | Unix home directories         |
| Path body                 | `/foo/bar-1`      | Subdirectories/files          |

* Regex: markdown ** asterisk
: "\\(^\\|[^*]\\)\\(\\*\\*\\*\\|\\*\\*\\)"
used in the markdown fontifier.

---
# Explanation by Parts
## 1. Regex Structure
- `\\(^\\|[^*]\\)` — **Group 1**:
  Matches either the beginning of a line (`^`),
  **OR** any character that is NOT an asterisk (`[^*]`).

- `\\(\\*\\*\\*\\|\\*\\*\\)` — **Group 2**:
  Matches either three asterisks (`***`)
  **OR** two asterisks (`**`).
  (The backslashes `\\` are needed for escaping in Elisp strings.)

## 2. Why This Structure?
- **Objective:**
  Find "**" or "***" markers in the text,
  but avoid matching sequences where asterisks are part of a longer
 run (like "****")
  and avoid overlapping matches.

- By requiring either line start or a non-asterisk before the marker,
  you reduce false positives and overlapping matches.

## 3. Match Groups
- **Group 1**: Context before the marker (not fontified).
- **Group 2**: The bold marker itself (to be fontified).

## 4. How It Works in Practice
### Example 1: Simple start-of-line
```
**bold**
```
- At position 0: Line start, matches `^`
- Next: "**" matches Group 2.

### Example 2: After space
```
some **bold**
```
- The space is not an asterisk, so `[^*]` matches.
- "**" matches Group 2.

### Example 3: Avoid overlap
```
****bold****
```
- After the first "**", the next "*" is part of "****",
  so `[^*]` doesn't match.
- Only the initial "**" or "***" are targeted.

---
# Summary Table
| Part                | Meaning                               |
|---------------------|---------------------------------------|
| `\\(^\\|[^*]\\)`    | Start of line OR not an asterisk      |
| `\\*\\*\\*\\|\\*\\*`| "***" OR "**" (the marker itself)     |

* Indent line for markdown subblock
~org-indent-line~ do (org-babel-do-in-edit-buffer (indent-according-to-mode))
~(org-babel-do-in-edit-buffer (funcall func))~ - check that at src-block and do
~(org-babel-do-in-edit-buffer (&rest body)~ - save point as marker and do
1) (org-edit-src-code)

(org-src--edit-element
- datum - element parsed with org-element-type - *Org syntax node* as a list
  - uses :language, :type (by org-element-type), :label-fmt, :type :begin (org-src--contents-area)
- name - language string
- initlalize - (lambda ()
  - activate mode
  - (org-escape-code-in-region (point-min) (point-max)))
2) (progn ,@body)
3) (org-edit-src-exit)

*Org syntax node* - [[org-element-ast.el::40]]

(list :type (org-element--get-cached-string type)
             :type-explicit-p explicit-type-p
	     :path path
	     :format format
	     :raw-link (or raw-link path)
	     :application application
	     :search-option search-option
	     :begin begin
	     :end end
	     :contents-begin contents-begin
	     :contents-end contents-end
	     :post-blank post-blank)
* Working with prefixes
We use
- RestAPI -> system -> Prefix
- Prefix -> system -> RestAPI

#+begin_src elisp :lexical t :results none :exports code :eval no
;; RestAPI -> Prefix
(let* ((role "user1")
       (role-oai (or (cdr (assoc-string role oai-block-roles-restapi))
                     oai-block-roles-restapi-unknown)))
  (car (rassoc role-oai oai-block-roles-prefixes))) ; => "ai+"

;; Prefix -> system
(let ((role "+me1"))
  (or (cdr (assoc-string role oai-block-roles-prefixes)) ; Get value by key
      oai-block-roles-prefixes-unknown)) ; => assistant
#+end_src

* Function for ``` markdown blocks
- oai-block--markdown-begin-end - any ``` block at separate lines.
- oai-block--markdown-lang-begin-end - ``` with language
* Org noweb
** how:
Expand links on  evaluating, tangling, or exporting.
- Doc https://orgmode.org/manual/Noweb-Reference-Syntax.html


#+begin_src org
,#+NAME: initialization
,#+BEGIN_SRC emacs-lisp
  (setq sentence "Never a foot too far, even.")
,#+END_SRC

,#+BEGIN_SRC emacs-lisp :noweb yes
  <<initialization>>
  (reverse sentence)
,#+END_SRC

Expanded to:
,#+BEGIN_SRC emacs-lisp :noweb yes
  (setq sentence "Never a foot too far, even.")
  (reverse sentence)
,#+END_SRC

#+end_src
** test
#+NAME: initialization
#+BEGIN_SRC emacs-lisp
  (setq sentence "Never a foot too far, even.")
#+END_SRC

#+RESULTS: initialization
: Never a foot too far, even.


(org-babel-get-src-block-info) - src
: ("emacs-lisp" "  (setq sentence \"Never a foot too far, even.\")" ((:colname-names) (:rowname-names) (:result-params "replace") (:result-type . value) (:results . "replace") (:exports . "code") (:lexical . "no") (:tangle . "no") (:hlines . "no") (:noweb . "no") (:cache . "no") (:session . "none") ...) "" "initialization" 8809 "(ref:%s)")

(org-babel-expand-noweb-references (oai-block-get-info))


: (oai-block-get-info)
((:stream . "nil") (:max-tokens . 1200) (:sys . "Be helpful.") (:service . "github") (:model . "openai/gpt-4.1"))

(org-babel--expand-body (oai-block-get-info)
#+begin_ai :noweb yes :stream nil :max-tokens 1200 :sys "Be helpful."  :service github :model "openai/gpt-4.1"
<<initialization>>
#+end_ai
: -----------------------------------------------------------

#+begin_src elisp :noweb yes :lexical t :results none :exports code :eval yes
<<initialization>>
(org-babel-expand-noweb-references (list "markdown" "```lisp\n<<initialization>>\n```"))
#+end_src

(org-babel--expand-body (org-babel-get-src-block-info))
** main function
#+begin_src elisp :lexical t :results none :exports code :eval no
(defun my/org-babel-noweb-p (params context)
  "Check if PARAMS require expansion in CONTEXT.
CONTEXT may be one of :tangle, :export or :eval."
  (let ((allowed-values (cl-case context
			  (:tangle '("yes" "tangle" "no-export" "strip-export" "strip-tangle"))
			  (:eval   '("yes" "no-export" "strip-export" "eval" "strip-tangle"))
			  (:export '("yes" "strip-tangle")))))
    (cl-some (lambda (v) (member v allowed-values))
	     (split-string (or (cdr (assq :noweb params)) "")))))

(let ((info '((:noweb . "no") (:stream . "nil") (:max-tokens . 1200) (:sys . "Be helpful.") (:service . "github") (:model . "openai/gpt-4.1"))))
  (my/org-babel-noweb-p info :eval))
#+end_src
** implementation
: (org-babel-expand-noweb-references (list "markdown" unexpanded-content))
* Tests: Not covered staff
- font-locks
- fill paragraph
