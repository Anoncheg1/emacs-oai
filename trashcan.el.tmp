;; -*- lexical-binding: t -*-
;; - for org-element-at-point to work and oai-where-is-src-block-result
;; - breaks 'fill-paragraph
(when (boundp 'org-element-greater-elements)
  (setq org-element-greater-elements (remove 'special-block org-element-greater-elements)))

;; (defun oai-block--org-fill-element-advice (func-call &rest args)
(defun oai-block-fill-paragraph (&optional justify region)
  (interactive (progn
		 (barf-if-buffer-read-only)
		 (list (when current-prefix-arg 'full) t)))
  (oai-block--org-fill-element-advice justify)
  )
(setq-local fill-paragraph-function 'oai-block-fill-paragraph)

(defun oai-block--org-fill-element-advice (func-call &rest args)
  (let ((justify (car args)))
  (with-syntax-table org-mode-transpose-word-syntax-table
    (let ((element (save-excursion (end-of-line) (org-element-at-point))))
      ;; (if (org-element-type element)
      (if (string-equal "ai" (org-element-property :type element))
          ;; - fixed part of part of `org-fill-element' for paragraph
          ;; Paragraphs may contain `line-break' type objects.
	  (let ((beg (max (point-min) (org-element-contents-begin element)))
                (end (min (point-max) (org-element-contents-end element))))
            ;; Do nothing if point is at an affiliated keyword.
            (unless (< (line-end-position) beg)
              (save-excursion
                (goto-char beg)
                (let ((regions (list (make-marker))))
                  ;; Set marker for the start of the first region.
                  (set-marker (car regions) beg)
                  ;; Collect region boundaries by finding empty lines, using markers.
                  (while (< (point) end)
                    (if (looking-at-p "^[ \t]*$")
                        (progn
                          (push (make-marker) regions)
                          (set-marker (car regions) (point))
                          (forward-line 1))
                      (forward-line 1)))
                  ;; Set marker for the end of the last region.
                  (push (make-marker) regions)
                  (set-marker (car regions) end)
                  (setq regions (nreverse regions))
                  ;; Apply fill-paragraph to each region.
                  (while (cdr regions)
                    (let ((region-beg (marker-position (car regions)))
                          (region-end (marker-position (cadr regions))))
                      (when (> region-end region-beg)
                        (fill-region-as-paragraph region-beg region-end justify))
                      (pop regions)))
                  ;; Clean up markers to avoid memory leaks.
                  (dolist (m regions)
                    (set-marker m nil))))
              t))
)
      )
  )))

(advice-add 'org-fill-element :after #'oai-block--org-fill-element-advice)

(defun oai-block--org-element-context-advice (func-call &rest args)
  "For `org-babel-where-is-src-block-result'.
Allow to simplify code by using many org-babel functions."
  (if (not (assq 'oai-mode minor-mode-alist))
      (apply func-call args)
    ;; else
    (let ((element (apply func-call args))) ;          (type (org-element-property :type element)))
      (if (string-equal "ai" (org-element-property :type element))
          (cons 'src-block (cdr element)) ; fake "ai" special-block as src-block
        ;; else
        element))))
;; - required for org-babel-where-is-src-block-result
(advice-add 'org-element-context :around #'oai-block--org-element-context-advice)
;; - required?????
;; (advice-add 'org-element-at-point :around #'oai-block--org-element-context-advice)


(defun oai-openai--get-greatest-variable (alist)
    (if (null alist)
        nil
      (car (sort alist (lambda (x y) (> (cdr x) (cdr y)))))))

;; (equal (oai-openai--get-greatest-variable '((bb . 3) (aa . 2))) '(bb . 3))
;; (equal (oai-openai--get-greatest-variable '((aa . 2) (bb . 3))) '(bb . 3))
;; (equal (oai-openai--get-greatest-variable '((cc . 1)))          '(cc . 1))
;; (equal (oai-openai--get-greatest-variable '())                  nil)

(defun apply-to-old-keys (seconds timed-alist func)
  "Remove keys from `timed-alist' whose timestamps are older than SECONDS seconds."
  (let ((current (time-to-seconds (current-time))))
    (mapc func (seq-filter
                (lambda (entry)
                  (<= (- current (time-to-seconds (cdr entry))) seconds))
                timed-alist)))

(defun oai--progress-reporter-update ()
  "2) interrupt
3) Remove keys"
  (apply-to-old-keys oai-progress-duration
                     oai-block--element-marker-variable-dict
                     (lambda ()
                       )))


(defun oai--progress-reporter-global-cancel (block-marker &optional failed)
  "Stop progress notification for element.
BLOCK-MARKER is marker for ai block header from
`oai-block-get-header-marker'."
  (oai-block--set-variable :value nil :block-header-marker block-marker)

  (when-let ((apply-to-old-keys oai-progress-duration
                                oai-block--element-marker-variable-dict

               (time-longest  (oai-openai--get-greatest-variable oai-block--element-marker-variable-dict))
  oai-block--element-marker-variable-dict

  (when oai--current-progress-reporter

    (if failed ; timeout
        (progn ; from `url-queue-kill-job'
          ;; (progress-reporter-done oai--current-progress-reporter)
          (progress-reporter-update oai--current-progress-reporter nil "- Connection failed")
          (message (concat oai--progress-reporter-waiting-string "- Connection failed"))
          (setq oai--current-progress-reporter nil)
          (oai-interrupt-current-request)
          ;; (when (buffer-live-p oai--last-url-buffer)
          ;;   (oai--kill-query-process))
          )
      ;; else success
      (progress-reporter-done oai--current-progress-reporter)
      (setq oai--current-progress-reporter nil)))
  ;; clear time
  (when oai--current-progress-timer
    (cancel-timer oai--current-progress-timer)
    (setq oai--current-progress-timer-remaining-ticks 0)))


(cl-defun oai-restapi-request-sync (service model timeout &optional &key prompt messages max-tokens temperature top-p frequency-penalty presence-penalty)
  "Return nil or result of `oai-restapi--normalize-response'.
To a"
  (let ((url-request-extra-headers (oai--get-headers service))
        (url-request-method "POST")
        (endpoint (oai-restapi--get-endpoint messages service))
        (url-request-data (oai-restapi--payload :prompt prompt
					   :messages messages
					   :model model
					   :max-tokens max-tokens
					   :temperature temperature
					   :top-p top-p
					   :frequency-penalty frequency-penalty
					   :presence-penalty presence-penalty
					   :service service
					   :stream nil)))
    (oai--debug "oai-restapi-request-sync endpoint:" endpoint (type-of endpoint)
                   "request-data:" (oai-restapi--prettify-json-string url-request-data)
                   )
    (let ((url-request-buffer
           (url-retrieve-synchronously ; <- - - - - - - - -  MAIN
            endpoint
            t
            t
            timeout)))
      (if url-request-buffer
          (with-current-buffer url-request-buffer
            (oai--debug-urllib url-request-buffer)
            (oai-restapi--maybe-show-openai-request-error) ; TODO: change to RESULT by global customizable option

            ;; - read from url-buffer
            (when (and (boundp 'url-http-end-of-headers) url-http-end-of-headers)
              (goto-char url-http-end-of-headers)
              (let ((json-object-type 'plist)
                    (json-key-type 'symbol)
                    (json-array-type 'vector))
                (condition-case _err
                    ;; ;; (#s(oai-restapi--response role "assistant") #s(oai-restapi--response text "It seems ") #s(oai-restapi--response stop "length"))
                    ;; (let* ((res1 (buffer-substring-no-properties (point) (point-max)))
                    ;;        (res2 (json-read-from-string res1))
                    ;;        (res3 (oai-restapi--normalize-response res2))
                    ;;        (res4 (nth 1 res3))
                    ;;        (res5 (oai-restapi--response-payload res4))
                    ;;        (res (decode-coding-string res5 'utf-8)))
                    ;;   res
                    ;;   )
                    (decode-coding-string (oai-restapi--response-payload (nth 1
                                                                         (oai-restapi--normalize-response
                                                                          (json-read-from-string
                                                                           (buffer-substring-no-properties (point) (point-max))))))
                                          'utf-8)
                  (error nil)))))
        ;; else
        (print "oai-restapi-request-sync: timeout for request")
        (oai--debug "oai-restapi-request-sync: timeout for request:" service model messages)))))

(let ((service 'together)
      (model "meta-llama/Llama-3.3-70B-Instruct-Turbo-Free")
      (max-tokens 99)
      (temperature nil)
      (top-p nil)
      (frequency-penalty nil)
      (presence-penalty nil))
  (oai-restapi-request-sync service model
                           99
                           :messages  (vector (list :role 'system :content "Be good.")
                                              (list :role 'user :content "How to do staff?"))
                           :max-tokens max-tokens
                           :temperature temperature
                           :top-p top-p
                           :frequency-penalty frequency-penalty
                           :presence-penalty presence-penalty))

(defun my/sync-request (messages service model timeout max-tokens top-p temperature frequency-penalty presence-penalty)
  "Do synchronous request.
Return string of LLM answer as assistent."
  (let ((lst '(0 1 2 3)) ; retries
        ret)
    (while (and (setq lst (cdr lst)) ; make list shorter
                (not ret)) ; ret is not nil?
      ;; second request
      (setq ret (oai-restapi-request-sync service model timeout
                                          :messages messages
                                          :max-tokens max-tokens
                                          :temperature temperature
                                          :top-p top-p
                                          :frequency-penalty frequency-penalty
                                          :presence-penalty presence-penalty))
      (setq timeout (* timeout 2)))
    ret))

(my/sync-request '([(:role system :content "Be helpful. Now, plan research of 3 parts and do only first part to answer this user request:") (:role user :content "How to live?") (:role system :content "Research 2-th part and what was missed before.")] together "meta-llama/Llama-3.3-70B-Instruct-Turbo-Free" 1.0e+INF "How to live?" 20 nil nil nil nil))


(defun oai-debug--error-async (err &optional bt-string  timeout)
  "Create Backtrace buffer without buttons async after TIMEOUT.
ERR is error object catched with `condition-case'.
Optional arguments:
TIMEOUT by default is nil, which mean 0
BT-STRING is a string, by default result
 of (with-output-to-string (backtrace))."
  (run-at-time timeout nil
               (lambda (b)
                 (with-current-buffer (generate-new-buffer "*Backtrace-async*")
                   (goto-char (point-max))
                   (insert (format "\nError: %s\nBacktrace:\n%s\n" err b))
                   (read-only-mode 1)
                   (special-mode) ; Gives buffer features like Backtrace
                   (pop-to-buffer (current-buffer)))
                 ;; rethrow preserving error type/args
                 (signal (car err) (cdr err)))
               (or bt-string
                   (let* ((backtrace-line-length 20) ; used by `backtrace-get-frames'
                          (print-level 3)
                          (print-length 10)
                          (bt
                           ;; (with-output-to-string (backtrace))
                           (backtrace-to-string (backtrace-get-frames 'backtrace))))
                     bt)
                   ;; (with-output-to-string (backtrace))
                   )))


;; not used
(cl-defun oai-optional-remove-distant-empty-lines-old (start end)
  "Remove empty lines in current buffer between START and END.
Removes an empty line only if another empty line is two lines above
it.
Empty line is blank or whitespace-only.
Does not remove an empty line if the line immediately following it
contains [ME]:"
  (interactive "r")

  (let ((lines-to-delete-pos '())
        (original-start start)
        (original-end end))

    (save-excursion
      ;; Phase 1: Collect info about lines in the region.
      ;; Each element: (line-start-position is-blank-p line-text)
      (let ((line-data-list '()))
        (goto-char start)
        (while (and (< (point) end) (not (eobp))) ; Iterate as long as point is within region and not end of buffer
          (let* ((line-start-pos (line-beginning-position))
                 (line-end-pos (line-end-position))
                 (line-text (buffer-substring-no-properties line-start-pos line-end-pos))
                 (is-blank (string-blank-p line-text)))
            ;; Store as a simple list: (position is-blank-p line-text)
            (push (list line-start-pos is-blank line-text) line-data-list))
          (forward-line 1))
        (setq line-data-list (nreverse line-data-list)) ; Reverse to get in document order

        ;; Phase 2: Identify lines for deletion.
        ;; Iterate through the list with indices to check previous and next lines efficiently.
        (dotimes (i (length line-data-list))
          ;; Use cl-destructuring-bind for clear access to current line's data
          (seq-let (current-line-pos current-is-blank current-text) (nth i line-data-list)
            (ignore current-text)
          ;; (cl-destructuring-bind (current-line-pos current-is-blank current-text)
          ;;     (nth i line-data-list)
            (let* (
                   ;; Safely get blank status for previous two lines
                   (prev-line-is-blank
                    (and (> i 0)
                         (let ((prev-data (nth (1- i) line-data-list)))
                           ;; (nth 1 prev-data) gets the 'is-blank-p' value (second element of the list)
                           (if prev-data (nth 1 prev-data) nil))))

                   (prev-prev-line-is-blank
                    (and (> i 1)
                         (let ((prev-prev-data (nth (- i 2) line-data-list)))
                           ;; (nth 1 prev-prev-data) gets the 'is-blank-p' value
                           (if prev-prev-data (nth 1 prev-prev-data) nil))))

                   ;; Safely get text for the next line
                   (next-line-text
                    (and (< (1+ i) (length line-data-list))
                         (let ((next-data (nth (1+ i) line-data-list)))
                           ;; (nth 2 next-data) gets the 'line-text' value (third element of the list)
                           (if next-data (nth 2 next-data) nil))))

                   (next-line-contains-me-p (and next-line-text (string-match-p "\\[ME\\]:" next-line-text))))

              ;; Condition for deletion:
              ;; 1. Current line is blank.
              ;; 2. Line two steps back was blank.
              ;; 3. The next line does NOT contain "[ME]:".
              (when (and current-is-blank
                         (or prev-prev-line-is-blank prev-line-is-blank)
                         (not next-line-contains-me-p))
                (push current-line-pos lines-to-delete-pos))))))

    ;; Phase 3: Delete the identified lines.
    ;; Delete from largest position to smallest to avoid invalidating positions.
    (save-excursion
      (dolist (pos lines-to-delete-pos)
        ;; Ensure the position is still within the original bounds.
        (when (and (>= pos original-start) (< pos original-end))
          (goto-char pos)
          ;; Delete the current line, including its trailing newline.
          (delete-region (point) (progn (forward-line 1) (point))))))

    ;; (message "Removed empty lines based on condition.")
    )))

(defun oai-optional-remove-distant-empty-lines-hook-function (type content before-pos stream)
  "Remove empty lines when there is too many of them.
TYPE _CONTENT BEFORE-POS BUF parameters described in
`oai-block-after-chat-insertion-hook' hook.
Argument STREAM not used."
  (ignore content stream)
  (save-excursion
    (oai--debug "IN A HOOK oai-optional-remove-distant-empty-lines-hook-function: %s %s %s %s"
                before-pos
                (point)
                type
                (type-of type))
    (when (equal type 'end)
      (let* ((area (oai-block--contents-area))
             (con-beg (car area))
             (con-end (cdr area)))
        (oai-optional-remove-distant-empty-lines con-beg con-end)))))

;; (defcustom oai-optional-fill-paragraph-functions
;;   (list
;;    'org-fill-paragraph)
;;    "List of steps to perform in the `my/org-fill-paragraph' function.
;; Replace single `fill-paragraph-function' variable with list of
;; functions."
;;   :type '(repeat function)
;;   :group 'oai)

;; -=-= old: fill-paragraph (old, not used)
;; (defun oai-optional-fill-paragraph (&optional justify region)
;;   "Call functions until success.
;; Replace single `fill-paragraph-function' with list of functions.
;; Optional argument JUSTIFY is parameter of `fill-paragraph'.
;; Optional argument REGION ."
;;   (interactive (progn
;; 		 (barf-if-buffer-read-only)
;; 		 (list (when current-prefix-arg 'full) t)))
;;   ;; call in loop functions, untill one return true
;;   (seq-find (lambda(step)
;;                 ;; (message step) ; debug
;;                 (funcall step justify region))
;;             my/org-fill-paragraph-functions))

;; Usage:
;; (setq oai-optional-fill-paragraph-functions
;;           (append (list #'my/oai-fill-paragraph)
;;                   oai-optional-fill-paragraph-functions))

;; (keymap-set org-mode-map \"M-q\" #'oai-optional-fill-paragraph)


;; -=-= old: remove-distant-empty-lines (old version)
;; (cl-defun oai-optional-remove-distant-empty-lines (start end)
;;   "Remove empty lines in current buffer between START and END.
;; Removes an empty line only if another empty line is two lines above it.
;; An 'empty line' is blank or whitespace-only.

;; Example:
;;   Original:      Result:
;;   line 1         line 1
;;                  (empty A) (kept)  (empty A)
;;   line 2         line 2
;;                  (empty B) (removed)line 3
;;   line 3         line 4
;;                  (empty C) (removed)line 5
;;   line 4         (empty D)
;;   line 5         line 6
;;                  (empty D) (kept)
;;   line 6

;; Case ME:
;; line 1         line 1
;;                  (empty A) (kept)  (empty A)
;; line 2         line 2
;;                  (empty B) (not removed)
;; line 3 with [ME]:   line 4
;; "
;;   (interactive "r") ;; Usable interactively on a selected region.

;;   (let ((lines-to-delete-pos '()) ; Stores positions of lines to remove.
;;         (line-info-list '())      ; Stores (line-pos . is-blank-p) for all lines in region.
;;         (original-start start)    ; Store original region start for robustness.
;;         (original-end end))       ; Store original region end for robustness.

;;     (save-excursion ;; Preserve point and mark positions after execution.

;;       ;; Phase 1: Collect info about lines in the region.
;;       ;; Iterate through the region, recording each line's starting position
;;       ;; and whether it's blank (contains only whitespace).
;;       (goto-char start)
;;       (while (< (point) end)
;;         (push (cons (point) (string-blank-p (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
;;               line-info-list)
;;         (forward-line 1))
;;       ;; Reverse the list to get lines in document order (top to bottom).
;;       (setq line-info-list (nreverse line-info-list))

;;       ;; Phase 2: Identify lines for deletion.
;;       ;; Iterate through the collected line information, keeping track of the
;;       ;; blank status of the previous two lines to apply the condition.
;;       (let ((line-minus-1-info nil) ; Stores (pos . is-blank) for the line one step back.
;;             (line-minus-2-info nil)) ; Stores (pos . is-blank) for the line two steps back.
;;         (dolist (current-line-info line-info-list)
;;           (let* ((current-line-pos (car current-line-info))
;;                  (current-line-is-blank (cdr current-line-info)))

;;             ;; Condition for deletion: current line is blank AND the line two steps back existed
;;             ;; and was also blank.
;;             (when (and current-line-is-blank
;;                        line-minus-2-info             ; Check if line two steps back actually exists.
;;                        (cdr line-minus-2-info))      ; Check if that line was blank.
;;               ;; If condition met, mark current line for deletion.
;;               ;; `push` adds positions to the front, so the list will be in reverse order
;;               ;; of appearance (later lines appear first in the list), which is ideal for deletion.
;;               (push current-line-pos lines-to-delete-pos)))

;;           ;; Update history for the next iteration:
;;           ;; Old 'minus-1' becomes new 'minus-2'.
;;           ;; Current line becomes new 'minus-1'.
;;           (setq line-minus-2-info line-minus-1-info)
;;           (setq line-minus-1-info current-line-info))))

;;     ;; Phase 3: Delete the identified lines.
;;     ;; Iterate through `lines-to-delete-pos`. Since it's already ordered from
;;     ;; the largest position to the smallest, deletions occur safely from the
;;     ;; end of the region towards the beginning, preventing position invalidation.
;;     (save-excursion
;;       (dolist (pos lines-to-delete-pos)
;;         ;; Robustness check: Ensure the position is still within the original bounds.
;;         (when (and (>= pos original-start) (< pos original-end))
;;           (goto-char pos) ; Move point to the start of the line to be deleted.
;;           ;; Delete the current line, including its trailing newline.
;;           (delete-region (point) (progn (forward-line 1) (point))))))

;;     (message "Removed empty lines based on condition.")))
